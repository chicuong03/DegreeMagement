"use client";

import { getContract } from "@/lib/contract";
import { BarElement, CategoryScale, Chart as ChartJS, Legend, LinearScale, Title, Tooltip } from "chart.js";
import { ethers } from "ethers";
import { saveAs } from "file-saver";
import { jsPDF } from "jspdf";
import autoTable from "jspdf-autotable";
import { useEffect, useState } from "react";
import { Button, Container, Form, Modal, Table } from "react-bootstrap";
import { Bar } from "react-chartjs-2";
import { toast } from "react-toastify";

// üîπ ƒêƒÉng k√Ω c√°c th√†nh ph·∫ßn c·∫ßn thi·∫øt
ChartJS.register(CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend);

interface Degree {
    id: string;              // ID c·ªßa b·∫±ng c·∫•p
    degreeId: string;        // M√£ b·∫±ng c·∫•p
    studentName: string;     // T√™n sinh vi√™n
    university: string;      // Tr∆∞·ªùng ƒë·∫°i h·ªçc
    dateOfBirth: string;     // Ng√†y sinh
    graduationDate: string;  // Ng√†y t·ªët nghi·ªáp
    grade: string;           // X·∫øp lo·∫°i
    score: number;           // ƒêi·ªÉm t·ªïng k·∫øt
    issueDate: string;       // Ng√†y c·∫•p b·∫±ng
    ipfsHash: string;        // Hash IPFS l∆∞u tr·ªØ b·∫±ng c·∫•p
    timestamp: string;       // Th·ªùi gian th·ª±c hi·ªán h√†nh ƒë·ªông
    status: "Pending" | "Approved" | "Rejected";
}

const DegreeHistoryPage = () => {
    const [degreeHistory, setDegreeHistory] = useState<Degree[]>([]);
    const [searchText, setSearchText] = useState<string>("");
    const [loading, setLoading] = useState<boolean>(true);
    const [showDetailModal, setShowDetailModal] = useState<boolean>(false);
    const [selectedDegree, setSelectedDegree] = useState<Degree | null>(null);
    const [suggestions, setSuggestions] = useState<string[]>([]);

    const fetchDegrees = async () => {
        if (!window.ethereum) {
            toast.error("Vui l√≤ng k·∫øt n·ªëi MetaMask!");
            return;
        }

        setLoading(true);

        try {
            // K·∫øt n·ªëi v·ªõi MetaMask
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const contract = getContract(provider); // L·∫•y h·ª£p ƒë·ªìng

            // Ki·ªÉm tra n·∫øu MetaMask ƒë√£ k·∫øt n·ªëi ƒë√∫ng
            const network = await provider.getNetwork();
            console.log("Network:", network);

            // L·∫•y t·ªïng s·ªë b·∫±ng c·∫•p
            const totalDegrees = await contract.totalDegrees();
            console.log("Total Degrees:", totalDegrees.toString());

            if (totalDegrees.toNumber() === 0) {
                toast.warn("Kh√¥ng c√≥ b·∫±ng c·∫•p n√†o ƒë∆∞·ª£c t√¨m th·∫•y!");
                setLoading(false);
                return;
            }

            // L·∫•y danh s√°ch b·∫±ng c·∫•p t·ª´ blockchain
            const degrees: Degree[] = await Promise.all(
                Array.from({ length: totalDegrees.toNumber() }, async (_, i) => {
                    const degreeId = (i + 1).toString(); // ID b·∫Øt ƒë·∫ßu t·ª´ 1 (chuy·ªÉn th√†nh string)
                    const degree = await contract.getDegree(degreeId);

                    const issueTimestamp = degree.timestamp ? new Date(Number(degree.timestamp) * 1000).toLocaleDateString() : "Kh√¥ng c√≥ d·ªØ li·ªáu";

                    return {
                        id: degreeId,
                        degreeId: degreeId,
                        studentName: degree.studentName,
                        university: degree.university,
                        dateOfBirth: new Date(Number(degree.dateOfBirth) * 1000).toLocaleDateString(),
                        graduationDate: new Date(Number(degree.graduationDate) * 1000).toLocaleDateString(),
                        grade: degree.grade,
                        score: Number(degree.score),
                        ipfsHash: degree.ipfsHash,
                        issueDate: new Date(Number(degree.timestamp) * 1000).toLocaleDateString(),
                        status: degree.status === 0 ? "Pending" : degree.status === 1 ? "Approved" : "Rejected", // ƒê·∫£m b·∫£o tr·∫°ng th√°i ƒë√∫ng                      
                        timestamp: issueTimestamp, // Th√™m timestamp
                    };
                })
            );

            console.log("üìå Danh s√°ch b·∫±ng c·∫•p sau khi format:", degrees);
            setDegreeHistory(degrees); // L∆∞u danh s√°ch Degree v√†o state
        } catch (error) {
            console.error("‚ùå L·ªói khi l·∫•y d·ªØ li·ªáu t·ª´ blockchain:", error);
            toast.error("Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu t·ª´ blockchain!");
        } finally {
            setLoading(false);
        }
    };

    /** üîπ Hi·ªÉn th·ªã chi ti·∫øt */
    const handleShowDetails = (history: Degree) => {
        setSelectedDegree(history);
        setShowDetailModal(true);
    };

    useEffect(() => {
        if (searchText.trim() === "") {
            setSuggestions([]);
            return;
        }

        const matchedSuggestions = degreeHistory
            .filter((history) =>
                history.degreeId.includes(searchText) ||
                history.studentName.toLowerCase().includes(searchText.toLowerCase()) ||
                history.university.toLowerCase().includes(searchText.toLowerCase())
            )
            .map((history) => `${history.degreeId} - ${history.studentName} - ${history.university}`);

        setSuggestions(matchedSuggestions);
    }, [searchText, degreeHistory]);

    useEffect(() => {
        fetchDegrees();
    }, []);

    /** üîπ B·ªô l·ªçc t√¨m ki·∫øm */
    const filteredHistory = degreeHistory.filter((history) => {
        const lowerCaseSearch = searchText.toLowerCase();

        return (
            lowerCaseSearch === "" ||
            history.degreeId.toLowerCase().includes(lowerCaseSearch) ||  // üîπ T√¨m theo m√£ b·∫±ng c·∫•p
            history.studentName.toLowerCase().includes(lowerCaseSearch) ||  // üîπ T√¨m theo t√™n sinh vi√™n
            history.university.toLowerCase().includes(lowerCaseSearch)  // üîπ T√¨m theo t√™n tr∆∞·ªùng
        );
    });

    /** üîπ Xu·∫•t CSV */
    const exportToCSV = () => {
        if (degreeHistory.length === 0) {
            toast.error("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t!");
            return;
        }

        const csvHeader = ["Degree Code,Student Name,School,Date of Issue,Score"];
        const csvRows = degreeHistory.map(history =>
            `${history.degreeId},"${history.studentName}","${history.university}",${history.timestamp},"${history.score}"`
        );

        const csvContent = [csvHeader, ...csvRows].join("\n");
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });

        saveAs(blob, "degree_history.csv");
    };

    /** üîπ Xu·∫•t PDF */
    const exportToPDF = () => {
        if (degreeHistory.length === 0) {
            toast.error("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t!");
            return;
        }

        const doc = new jsPDF();
        doc.text("Degree History", 14, 10);
        doc.setFont("Arial");
        const tableColumn = ["Degree Id", "Student Name", "University", "Date Of Issue", "Score", "Holder"];
        const tableRows = degreeHistory.map(history => [
            history.degreeId,
            history.studentName,
            history.university,
            history.timestamp,
            history.score,
        ]);

        autoTable(doc, {
            head: [tableColumn],
            body: tableRows,
            startY: 20,
        });

        doc.save("degree_history.pdf");
    };

    // xu·∫•t pdf theo b·∫±ng
    const exportDegreePDF = (degree: Degree | null) => {
        if (!degree) {
            toast.error("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t!");
            return;
        }

        // üìù T·∫°o file PDF d·ªçc (A4 Portrait)
        const doc = new jsPDF({
            orientation: "portrait",
            unit: "mm",
            format: "a4"
        });

        // üñº Th√™m h√¨nh n·ªÅn watermark
        const img = new Image();
        img.src = "/images/trong1.jpg";

        img.onload = function () {
            const pageWidth = 210;
            const pageHeight = 297;
            // üì∏ CƒÉn ch·ªânh watermark full trang
            const imgAspectRatio = img.width / img.height;
            let imgWidth = pageWidth;
            let imgHeight = pageHeight;

            if (imgAspectRatio > 1) {
                imgWidth = pageHeight * imgAspectRatio;
            } else {
                imgHeight = pageWidth / imgAspectRatio;
            }

            const xOffset = (pageWidth - imgWidth) / 2;
            const yOffset = (pageHeight - imgHeight) / 2;

            doc.addImage(img, "PNG", xOffset, yOffset, imgWidth, imgHeight, "", "FAST");

            // üéì Ti√™u ƒë·ªÅ ch√≠nh
            doc.setFont("times", "bold");
            doc.setFontSize(26);
            doc.setTextColor(0, 0, 80);
            doc.text("DEGREE CERTIFICATION", pageWidth / 2, 40, { align: "center" });

            // üèõ Hi·ªÉn th·ªã tr∆∞·ªùng ƒë·∫°i h·ªçc
            doc.setFontSize(18);
            doc.setFont("times", "italic");
            doc.text(degree.university.toUpperCase(), pageWidth / 2, 55, { align: "center" });

            // üìú N·ªôi dung ch·ª©ng nh·∫≠n
            doc.setFontSize(14);
            doc.setFont("times", "normal");
            doc.text("This is to certify that", pageWidth / 2, 75, { align: "center" });

            doc.setFontSize(22);
            doc.setFont("times", "bold");
            doc.text(degree.studentName.toUpperCase(), pageWidth / 2, 90, { align: "center" });

            doc.setFontSize(14);
            doc.setFont("times", "normal");
            doc.text(
                "has successfully completed the certification process with the following details:",
                pageWidth / 2,
                105,
                { align: "center" }
            );

            // üîπ Th√¥ng tin ch√≠nh (n·∫±m ngo√†i b·∫£ng)
            doc.setFontSize(14);
            doc.setFont("times", "bold");
            doc.text("Degree ID:", 20, 125);
            doc.setFont("times", "normal");
            doc.text(degree.degreeId, 50, 125);

            doc.setFont("times", "bold");
            doc.text("Date Issued:", 20, 135);
            doc.setFont("times", "normal");
            doc.text(degree.timestamp, 50, 135);

            doc.setFont("times", "bold");
            doc.text("Grade:", 20, 145);
            doc.setFont("times", "normal");
            doc.text(degree.grade, 50, 145);

            doc.setFont("times", "bold");
            doc.text("Score:", 20, 155);
            doc.setFont("times", "normal");
            doc.text(degree.score !== undefined ? degree.score.toFixed(2) : "N/A", 50, 155);

            // üîπ Th√™m th√¥ng tin b·ªï sung (Ng√†y sinh, Ng√†y t·ªët nghi·ªáp, IPFS Hash)
            doc.setFont("times", "bold");
            doc.text("Date of Birth:", 20, 165);
            doc.setFont("times", "normal");
            doc.text(degree.dateOfBirth, 50, 165);

            doc.setFont("times", "bold");
            doc.text("Graduation Date:", 20, 175);
            doc.setFont("times", "normal");
            doc.text(degree.graduationDate, 50, 175);

            doc.setFont("times", "bold");
            doc.text("IPFS Hash:", 20, 185);
            doc.setFont("times", "normal");
            doc.text(degree.ipfsHash, 50, 185);

            // ‚úç Ch·ªØ k√Ω & Ng√†y c·∫•p
            doc.setFontSize(14);
            doc.setFont("times", "italic");
            doc.text("Authorized Signature:", 140, 260);
            doc.text("_________________", 140, 265);

            // üìÑ L∆∞u file PDF
            doc.save(`Degree_Certification_${degree.studentName}.pdf`);
        };
    };


    /** üîπ Th·ªëng k√™ s·ªë l∆∞·ª£ng c·∫•p b·∫±ng theo th√°ng */
    const getMonthlyStats = () => {
        const monthData: { [key: string]: number } = {};

        degreeHistory.forEach((history) => {
            const month = new Date(history.timestamp).toLocaleDateString("vi-VN", { month: "long", year: "numeric" });
            monthData[month] = (monthData[month] || 0) + 1;
        });

        return {
            labels: Object.keys(monthData), // Ph·∫£i l√† array c·ªßa string (category)
            datasets: [{
                label: "S·ªë l∆∞·ª£ng c·∫•p b·∫±ng theo th√°ng",
                data: Object.values(monthData),
                backgroundColor: "rgba(54, 162, 235, 0.6)",
            }],
        };
    };

    return (
        <Container>
            <h3 className="mb-4 mt-4">üìú L·ªãch S·ª≠ C·∫•p B·∫±ng</h3>

            <div style={{ position: "relative" }}>
                <Form.Control
                    type="text"
                    placeholder="üîç Nh·∫≠p m√£ b·∫±ng c·∫•p, t√™n sinh vi√™n ho·∫∑c tr∆∞·ªùng..."
                    value={searchText}
                    onChange={(e) => setSearchText(e.target.value)}
                    className="mb-3"
                />

                {suggestions.length > 0 && (
                    <ul style={{
                        position: "absolute",
                        backgroundColor: "white",
                        border: "1px solid #ddd",
                        borderRadius: "5px",
                        width: "100%",
                        listStyleType: "none",
                        padding: "10px",
                        margin: "0",
                        maxHeight: "150px",
                        overflowY: "auto",
                        zIndex: 1000
                    }}>
                        {suggestions.map((item, index) => (
                            <li key={index}
                                style={{ padding: "5px", cursor: "pointer" }}
                                onClick={() => setSearchText(item.split(" - ")[0])}>
                                {item}
                            </li>
                        ))}
                    </ul>
                )}
            </div>



            {/* üìÇ Xu·∫•t d·ªØ li·ªáu */}
            <div className="d-flex mb-3">
                <Button variant="success" onClick={exportToCSV}>
                    üìÇ Xu·∫•t CSV
                </Button>
                <Button variant="danger" className="ms-2" onClick={exportToPDF}>
                    üìë Xu·∫•t PDF
                </Button>
            </div>

            {/* üìã B·∫£ng l·ªãch s·ª≠ */}
            <Table striped bordered hover responsive>
                <thead>
                    <tr>
                        <th className="text-center align-middle">M√£ B·∫±ng C·∫•p</th>
                        <th className="text-center align-middle">T√™n Sinh Vi√™n</th>
                        <th className="text-center align-middle">Tr∆∞·ªùng</th>
                        <th className="text-center align-middle">Ng√†y C·∫•p</th>
                        <th className="text-center align-middle">ƒêi·ªÉm</th>
                        <th className="text-center align-middle">Chi Ti·∫øt</th>
                    </tr>
                </thead>
                <tbody>
                    {filteredHistory.length > 0 ? (
                        filteredHistory.map((history) => (
                            <tr key={history.degreeId}>
                                <td className="text-center align-middle" style={{
                                    width: "50px",
                                    maxWidth: "150px",
                                    overflow: "hidden",
                                    whiteSpace: "nowrap",
                                    textOverflow: "ellipsis"
                                }}>{history.degreeId}</td>
                                <td className="text-center align-middle">{history.studentName}</td>
                                <td className="text-center align-middle">{history.university}</td>
                                <td className="text-center align-middle">{history.timestamp}</td>
                                <td className="text-center align-middle">{history.score}</td>
                                <td className="text-center align-middle">
                                    <Button variant="info" size="sm" onClick={() => handleShowDetails(history)}>
                                        üîç Xem
                                    </Button>
                                </td>
                            </tr>
                        ))
                    ) : (
                        <tr>
                            <td className="text-center">‚ùå Kh√¥ng c√≥ l·ªãch s·ª≠ c·∫•p b·∫±ng</td>
                        </tr>
                    )}
                </tbody>
            </Table>

            {/* üìä Bi·ªÉu ƒë·ªì th·ªëng k√™ */}
            {degreeHistory.length > 0 && (
                <div className="my-4">
                    <h4>üìä Th·ªëng K√™ C·∫•p B·∫±ng Theo Th√°ng</h4>
                    <Bar data={getMonthlyStats()} />
                </div>
            )}
            <Modal show={showDetailModal} onHide={() => setShowDetailModal(false)} size="lg">
                <Modal.Header closeButton>
                    <Modal.Title>üìú Chi Ti·∫øt B·∫±ng C·∫•p</Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    {selectedDegree ? (
                        <div>
                            <p><strong>üÜî M√£ B·∫±ng C·∫•p:</strong> {selectedDegree.degreeId}</p>
                            <p><strong>üë®‚Äçüéì T√™n Sinh Vi√™n:</strong> {selectedDegree.studentName}</p>
                            <p><strong>üè´ Tr∆∞·ªùng ƒê·∫°i H·ªçc:</strong> {selectedDegree.university}</p>
                            <p><strong>üìÖ Ng√†y C·∫•p:</strong> {selectedDegree.timestamp}</p>
                            <p><strong>üî¢ ƒêi·ªÉm S·ªë:</strong> {selectedDegree.score !== undefined ? selectedDegree.score.toFixed(2) : "N/A"}</p>
                            <p><strong>üìÖ Ng√†y Sinh:</strong> {selectedDegree.dateOfBirth}</p>
                            <p><strong>ipfsHash:</strong> {selectedDegree.ipfsHash}</p>
                        </div>
                    ) : (
                        <p>Kh√¥ng c√≥ d·ªØ li·ªáu.</p>
                    )}
                </Modal.Body>
                <Modal.Footer>
                    <Button
                        variant="primary"
                        onClick={() => {
                            if (selectedDegree) {
                                exportDegreePDF(selectedDegree);
                            } else {
                                toast.error("Kh√¥ng c√≥ d·ªØ li·ªáu b·∫±ng c·∫•p ƒë·ªÉ xu·∫•t PDF!");
                            }
                        }}
                    >
                        üìÑ Xu·∫•t PDF
                    </Button>

                    <Button variant="secondary" onClick={() => setShowDetailModal(false)}>ƒê√≥ng</Button>
                </Modal.Footer>
            </Modal>

        </Container>
    );
};

export default DegreeHistoryPage;
